// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: gz/msgs/actor.proto

#ifndef PROTOBUF_INCLUDED_gz_2fmsgs_2factor_2eproto
#define PROTOBUF_INCLUDED_gz_2fmsgs_2factor_2eproto

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3006001
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3006001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/inlined_string_field.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/unknown_field_set.h>
#include "gz/msgs/entity.pb.h"
#include "gz/msgs/header.pb.h"
#include "gz/msgs/pose.pb.h"
// @@protoc_insertion_point(includes)
#define PROTOBUF_INTERNAL_EXPORT_protobuf_gz_2fmsgs_2factor_2eproto IGNITION_MSGS_VISIBLE

namespace protobuf_gz_2fmsgs_2factor_2eproto {
// Internal implementation detail -- do not use these members.
struct IGNITION_MSGS_VISIBLE TableStruct {
  static const ::google::protobuf::internal::ParseTableField entries[];
  static const ::google::protobuf::internal::AuxillaryParseTableField aux[];
  static const ::google::protobuf::internal::ParseTable schema[4];
  static const ::google::protobuf::internal::FieldMetadata field_metadata[];
  static const ::google::protobuf::internal::SerializationTable serialization_table[];
  static const ::google::protobuf::uint32 offsets[];
};
void IGNITION_MSGS_VISIBLE AddDescriptors();
}  // namespace protobuf_gz_2fmsgs_2factor_2eproto
namespace gz {
namespace msgs {
class Actor;
class ActorDefaultTypeInternal;
IGNITION_MSGS_VISIBLE extern ActorDefaultTypeInternal _Actor_default_instance_;
class Actor_Animation;
class Actor_AnimationDefaultTypeInternal;
IGNITION_MSGS_VISIBLE extern Actor_AnimationDefaultTypeInternal _Actor_Animation_default_instance_;
class Actor_Trajectory;
class Actor_TrajectoryDefaultTypeInternal;
IGNITION_MSGS_VISIBLE extern Actor_TrajectoryDefaultTypeInternal _Actor_Trajectory_default_instance_;
class Actor_Waypoint;
class Actor_WaypointDefaultTypeInternal;
IGNITION_MSGS_VISIBLE extern Actor_WaypointDefaultTypeInternal _Actor_Waypoint_default_instance_;
}  // namespace msgs
}  // namespace gz
namespace google {
namespace protobuf {
template<> IGNITION_MSGS_VISIBLE ::gz::msgs::Actor* Arena::CreateMaybeMessage<::gz::msgs::Actor>(Arena*);
template<> IGNITION_MSGS_VISIBLE ::gz::msgs::Actor_Animation* Arena::CreateMaybeMessage<::gz::msgs::Actor_Animation>(Arena*);
template<> IGNITION_MSGS_VISIBLE ::gz::msgs::Actor_Trajectory* Arena::CreateMaybeMessage<::gz::msgs::Actor_Trajectory>(Arena*);
template<> IGNITION_MSGS_VISIBLE ::gz::msgs::Actor_Waypoint* Arena::CreateMaybeMessage<::gz::msgs::Actor_Waypoint>(Arena*);
}  // namespace protobuf
}  // namespace google
namespace gz {
namespace msgs {

// ===================================================================

class IGNITION_MSGS_VISIBLE Actor_Animation : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:gz.msgs.Actor.Animation) */ {
 public:
  Actor_Animation();
  virtual ~Actor_Animation();

  Actor_Animation(const Actor_Animation& from);

  inline Actor_Animation& operator=(const Actor_Animation& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Actor_Animation(Actor_Animation&& from) noexcept
    : Actor_Animation() {
    *this = ::std::move(from);
  }

  inline Actor_Animation& operator=(Actor_Animation&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Actor_Animation& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Actor_Animation* internal_default_instance() {
    return reinterpret_cast<const Actor_Animation*>(
               &_Actor_Animation_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  void Swap(Actor_Animation* other);
  friend void swap(Actor_Animation& a, Actor_Animation& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Actor_Animation* New() const final {
    return CreateMaybeMessage<Actor_Animation>(NULL);
  }

  Actor_Animation* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Actor_Animation>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Actor_Animation& from);
  void MergeFrom(const Actor_Animation& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Actor_Animation* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string name = 1;
  void clear_name();
  static const int kNameFieldNumber = 1;
  const ::std::string& name() const;
  void set_name(const ::std::string& value);
  #if LANG_CXX11
  void set_name(::std::string&& value);
  #endif
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  ::std::string* mutable_name();
  ::std::string* release_name();
  void set_allocated_name(::std::string* name);

  // string filename = 2;
  void clear_filename();
  static const int kFilenameFieldNumber = 2;
  const ::std::string& filename() const;
  void set_filename(const ::std::string& value);
  #if LANG_CXX11
  void set_filename(::std::string&& value);
  #endif
  void set_filename(const char* value);
  void set_filename(const char* value, size_t size);
  ::std::string* mutable_filename();
  ::std::string* release_filename();
  void set_allocated_filename(::std::string* filename);

  // float scale = 3;
  void clear_scale();
  static const int kScaleFieldNumber = 3;
  float scale() const;
  void set_scale(float value);

  // bool interpolate_x = 4;
  void clear_interpolate_x();
  static const int kInterpolateXFieldNumber = 4;
  bool interpolate_x() const;
  void set_interpolate_x(bool value);

  // @@protoc_insertion_point(class_scope:gz.msgs.Actor.Animation)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr name_;
  ::google::protobuf::internal::ArenaStringPtr filename_;
  float scale_;
  bool interpolate_x_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_gz_2fmsgs_2factor_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class IGNITION_MSGS_VISIBLE Actor_Waypoint : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:gz.msgs.Actor.Waypoint) */ {
 public:
  Actor_Waypoint();
  virtual ~Actor_Waypoint();

  Actor_Waypoint(const Actor_Waypoint& from);

  inline Actor_Waypoint& operator=(const Actor_Waypoint& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Actor_Waypoint(Actor_Waypoint&& from) noexcept
    : Actor_Waypoint() {
    *this = ::std::move(from);
  }

  inline Actor_Waypoint& operator=(Actor_Waypoint&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Actor_Waypoint& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Actor_Waypoint* internal_default_instance() {
    return reinterpret_cast<const Actor_Waypoint*>(
               &_Actor_Waypoint_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  void Swap(Actor_Waypoint* other);
  friend void swap(Actor_Waypoint& a, Actor_Waypoint& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Actor_Waypoint* New() const final {
    return CreateMaybeMessage<Actor_Waypoint>(NULL);
  }

  Actor_Waypoint* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Actor_Waypoint>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Actor_Waypoint& from);
  void MergeFrom(const Actor_Waypoint& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Actor_Waypoint* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .gz.msgs.Pose pose = 2;
  bool has_pose() const;
  void clear_pose();
  static const int kPoseFieldNumber = 2;
  private:
  const ::gz::msgs::Pose& _internal_pose() const;
  public:
  const ::gz::msgs::Pose& pose() const;
  ::gz::msgs::Pose* release_pose();
  ::gz::msgs::Pose* mutable_pose();
  void set_allocated_pose(::gz::msgs::Pose* pose);

  // float time = 1;
  void clear_time();
  static const int kTimeFieldNumber = 1;
  float time() const;
  void set_time(float value);

  // @@protoc_insertion_point(class_scope:gz.msgs.Actor.Waypoint)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::gz::msgs::Pose* pose_;
  float time_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_gz_2fmsgs_2factor_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class IGNITION_MSGS_VISIBLE Actor_Trajectory : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:gz.msgs.Actor.Trajectory) */ {
 public:
  Actor_Trajectory();
  virtual ~Actor_Trajectory();

  Actor_Trajectory(const Actor_Trajectory& from);

  inline Actor_Trajectory& operator=(const Actor_Trajectory& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Actor_Trajectory(Actor_Trajectory&& from) noexcept
    : Actor_Trajectory() {
    *this = ::std::move(from);
  }

  inline Actor_Trajectory& operator=(Actor_Trajectory&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Actor_Trajectory& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Actor_Trajectory* internal_default_instance() {
    return reinterpret_cast<const Actor_Trajectory*>(
               &_Actor_Trajectory_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  void Swap(Actor_Trajectory* other);
  friend void swap(Actor_Trajectory& a, Actor_Trajectory& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Actor_Trajectory* New() const final {
    return CreateMaybeMessage<Actor_Trajectory>(NULL);
  }

  Actor_Trajectory* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Actor_Trajectory>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Actor_Trajectory& from);
  void MergeFrom(const Actor_Trajectory& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Actor_Trajectory* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .gz.msgs.Actor.Waypoint waypoints = 4;
  int waypoints_size() const;
  void clear_waypoints();
  static const int kWaypointsFieldNumber = 4;
  ::gz::msgs::Actor_Waypoint* mutable_waypoints(int index);
  ::google::protobuf::RepeatedPtrField< ::gz::msgs::Actor_Waypoint >*
      mutable_waypoints();
  const ::gz::msgs::Actor_Waypoint& waypoints(int index) const;
  ::gz::msgs::Actor_Waypoint* add_waypoints();
  const ::google::protobuf::RepeatedPtrField< ::gz::msgs::Actor_Waypoint >&
      waypoints() const;

  // string type = 2;
  void clear_type();
  static const int kTypeFieldNumber = 2;
  const ::std::string& type() const;
  void set_type(const ::std::string& value);
  #if LANG_CXX11
  void set_type(::std::string&& value);
  #endif
  void set_type(const char* value);
  void set_type(const char* value, size_t size);
  ::std::string* mutable_type();
  ::std::string* release_type();
  void set_allocated_type(::std::string* type);

  // uint32 id = 1;
  void clear_id();
  static const int kIdFieldNumber = 1;
  ::google::protobuf::uint32 id() const;
  void set_id(::google::protobuf::uint32 value);

  // float tension = 3;
  void clear_tension();
  static const int kTensionFieldNumber = 3;
  float tension() const;
  void set_tension(float value);

  // @@protoc_insertion_point(class_scope:gz.msgs.Actor.Trajectory)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::gz::msgs::Actor_Waypoint > waypoints_;
  ::google::protobuf::internal::ArenaStringPtr type_;
  ::google::protobuf::uint32 id_;
  float tension_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_gz_2fmsgs_2factor_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class IGNITION_MSGS_VISIBLE Actor : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:gz.msgs.Actor) */ {
 public:
  Actor();
  virtual ~Actor();

  Actor(const Actor& from);

  inline Actor& operator=(const Actor& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Actor(Actor&& from) noexcept
    : Actor() {
    *this = ::std::move(from);
  }

  inline Actor& operator=(Actor&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Actor& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Actor* internal_default_instance() {
    return reinterpret_cast<const Actor*>(
               &_Actor_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  void Swap(Actor* other);
  friend void swap(Actor& a, Actor& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Actor* New() const final {
    return CreateMaybeMessage<Actor>(NULL);
  }

  Actor* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Actor>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Actor& from);
  void MergeFrom(const Actor& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Actor* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef Actor_Animation Animation;
  typedef Actor_Waypoint Waypoint;
  typedef Actor_Trajectory Trajectory;

  // accessors -------------------------------------------------------

  // repeated .gz.msgs.Actor.Animation animations = 6;
  int animations_size() const;
  void clear_animations();
  static const int kAnimationsFieldNumber = 6;
  ::gz::msgs::Actor_Animation* mutable_animations(int index);
  ::google::protobuf::RepeatedPtrField< ::gz::msgs::Actor_Animation >*
      mutable_animations();
  const ::gz::msgs::Actor_Animation& animations(int index) const;
  ::gz::msgs::Actor_Animation* add_animations();
  const ::google::protobuf::RepeatedPtrField< ::gz::msgs::Actor_Animation >&
      animations() const;

  // repeated .gz.msgs.Actor.Trajectory trajectories = 10;
  int trajectories_size() const;
  void clear_trajectories();
  static const int kTrajectoriesFieldNumber = 10;
  ::gz::msgs::Actor_Trajectory* mutable_trajectories(int index);
  ::google::protobuf::RepeatedPtrField< ::gz::msgs::Actor_Trajectory >*
      mutable_trajectories();
  const ::gz::msgs::Actor_Trajectory& trajectories(int index) const;
  ::gz::msgs::Actor_Trajectory* add_trajectories();
  const ::google::protobuf::RepeatedPtrField< ::gz::msgs::Actor_Trajectory >&
      trajectories() const;

  // string skin_filename = 4;
  void clear_skin_filename();
  static const int kSkinFilenameFieldNumber = 4;
  const ::std::string& skin_filename() const;
  void set_skin_filename(const ::std::string& value);
  #if LANG_CXX11
  void set_skin_filename(::std::string&& value);
  #endif
  void set_skin_filename(const char* value);
  void set_skin_filename(const char* value, size_t size);
  ::std::string* mutable_skin_filename();
  ::std::string* release_skin_filename();
  void set_allocated_skin_filename(::std::string* skin_filename);

  // .gz.msgs.Header header = 1;
  bool has_header() const;
  void clear_header();
  static const int kHeaderFieldNumber = 1;
  private:
  const ::gz::msgs::Header& _internal_header() const;
  public:
  const ::gz::msgs::Header& header() const;
  ::gz::msgs::Header* release_header();
  ::gz::msgs::Header* mutable_header();
  void set_allocated_header(::gz::msgs::Header* header);

  // .gz.msgs.Entity entity = 2;
  bool has_entity() const;
  void clear_entity();
  static const int kEntityFieldNumber = 2;
  private:
  const ::gz::msgs::Entity& _internal_entity() const;
  public:
  const ::gz::msgs::Entity& entity() const;
  ::gz::msgs::Entity* release_entity();
  ::gz::msgs::Entity* mutable_entity();
  void set_allocated_entity(::gz::msgs::Entity* entity);

  // .gz.msgs.Pose pose = 3;
  bool has_pose() const;
  void clear_pose();
  static const int kPoseFieldNumber = 3;
  private:
  const ::gz::msgs::Pose& _internal_pose() const;
  public:
  const ::gz::msgs::Pose& pose() const;
  ::gz::msgs::Pose* release_pose();
  ::gz::msgs::Pose* mutable_pose();
  void set_allocated_pose(::gz::msgs::Pose* pose);

  // .gz.msgs.Entity parent = 11;
  bool has_parent() const;
  void clear_parent();
  static const int kParentFieldNumber = 11;
  private:
  const ::gz::msgs::Entity& _internal_parent() const;
  public:
  const ::gz::msgs::Entity& parent() const;
  ::gz::msgs::Entity* release_parent();
  ::gz::msgs::Entity* mutable_parent();
  void set_allocated_parent(::gz::msgs::Entity* parent);

  // float skin_scale = 5;
  void clear_skin_scale();
  static const int kSkinScaleFieldNumber = 5;
  float skin_scale() const;
  void set_skin_scale(float value);

  // float script_delay_start = 8;
  void clear_script_delay_start();
  static const int kScriptDelayStartFieldNumber = 8;
  float script_delay_start() const;
  void set_script_delay_start(float value);

  // bool script_loop = 7;
  void clear_script_loop();
  static const int kScriptLoopFieldNumber = 7;
  bool script_loop() const;
  void set_script_loop(bool value);

  // bool script_auto_start = 9;
  void clear_script_auto_start();
  static const int kScriptAutoStartFieldNumber = 9;
  bool script_auto_start() const;
  void set_script_auto_start(bool value);

  // @@protoc_insertion_point(class_scope:gz.msgs.Actor)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::gz::msgs::Actor_Animation > animations_;
  ::google::protobuf::RepeatedPtrField< ::gz::msgs::Actor_Trajectory > trajectories_;
  ::google::protobuf::internal::ArenaStringPtr skin_filename_;
  ::gz::msgs::Header* header_;
  ::gz::msgs::Entity* entity_;
  ::gz::msgs::Pose* pose_;
  ::gz::msgs::Entity* parent_;
  float skin_scale_;
  float script_delay_start_;
  bool script_loop_;
  bool script_auto_start_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_gz_2fmsgs_2factor_2eproto::TableStruct;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// Actor_Animation

// string name = 1;
inline void Actor_Animation::clear_name() {
  name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Actor_Animation::name() const {
  // @@protoc_insertion_point(field_get:gz.msgs.Actor.Animation.name)
  return name_.GetNoArena();
}
inline void Actor_Animation::set_name(const ::std::string& value) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:gz.msgs.Actor.Animation.name)
}
#if LANG_CXX11
inline void Actor_Animation::set_name(::std::string&& value) {
  
  name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:gz.msgs.Actor.Animation.name)
}
#endif
inline void Actor_Animation::set_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:gz.msgs.Actor.Animation.name)
}
inline void Actor_Animation::set_name(const char* value, size_t size) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:gz.msgs.Actor.Animation.name)
}
inline ::std::string* Actor_Animation::mutable_name() {
  
  // @@protoc_insertion_point(field_mutable:gz.msgs.Actor.Animation.name)
  return name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Actor_Animation::release_name() {
  // @@protoc_insertion_point(field_release:gz.msgs.Actor.Animation.name)
  
  return name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Actor_Animation::set_allocated_name(::std::string* name) {
  if (name != NULL) {
    
  } else {
    
  }
  name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:gz.msgs.Actor.Animation.name)
}

// string filename = 2;
inline void Actor_Animation::clear_filename() {
  filename_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Actor_Animation::filename() const {
  // @@protoc_insertion_point(field_get:gz.msgs.Actor.Animation.filename)
  return filename_.GetNoArena();
}
inline void Actor_Animation::set_filename(const ::std::string& value) {
  
  filename_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:gz.msgs.Actor.Animation.filename)
}
#if LANG_CXX11
inline void Actor_Animation::set_filename(::std::string&& value) {
  
  filename_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:gz.msgs.Actor.Animation.filename)
}
#endif
inline void Actor_Animation::set_filename(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  filename_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:gz.msgs.Actor.Animation.filename)
}
inline void Actor_Animation::set_filename(const char* value, size_t size) {
  
  filename_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:gz.msgs.Actor.Animation.filename)
}
inline ::std::string* Actor_Animation::mutable_filename() {
  
  // @@protoc_insertion_point(field_mutable:gz.msgs.Actor.Animation.filename)
  return filename_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Actor_Animation::release_filename() {
  // @@protoc_insertion_point(field_release:gz.msgs.Actor.Animation.filename)
  
  return filename_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Actor_Animation::set_allocated_filename(::std::string* filename) {
  if (filename != NULL) {
    
  } else {
    
  }
  filename_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), filename);
  // @@protoc_insertion_point(field_set_allocated:gz.msgs.Actor.Animation.filename)
}

// float scale = 3;
inline void Actor_Animation::clear_scale() {
  scale_ = 0;
}
inline float Actor_Animation::scale() const {
  // @@protoc_insertion_point(field_get:gz.msgs.Actor.Animation.scale)
  return scale_;
}
inline void Actor_Animation::set_scale(float value) {
  
  scale_ = value;
  // @@protoc_insertion_point(field_set:gz.msgs.Actor.Animation.scale)
}

// bool interpolate_x = 4;
inline void Actor_Animation::clear_interpolate_x() {
  interpolate_x_ = false;
}
inline bool Actor_Animation::interpolate_x() const {
  // @@protoc_insertion_point(field_get:gz.msgs.Actor.Animation.interpolate_x)
  return interpolate_x_;
}
inline void Actor_Animation::set_interpolate_x(bool value) {
  
  interpolate_x_ = value;
  // @@protoc_insertion_point(field_set:gz.msgs.Actor.Animation.interpolate_x)
}

// -------------------------------------------------------------------

// Actor_Waypoint

// float time = 1;
inline void Actor_Waypoint::clear_time() {
  time_ = 0;
}
inline float Actor_Waypoint::time() const {
  // @@protoc_insertion_point(field_get:gz.msgs.Actor.Waypoint.time)
  return time_;
}
inline void Actor_Waypoint::set_time(float value) {
  
  time_ = value;
  // @@protoc_insertion_point(field_set:gz.msgs.Actor.Waypoint.time)
}

// .gz.msgs.Pose pose = 2;
inline bool Actor_Waypoint::has_pose() const {
  return this != internal_default_instance() && pose_ != NULL;
}
inline const ::gz::msgs::Pose& Actor_Waypoint::_internal_pose() const {
  return *pose_;
}
inline const ::gz::msgs::Pose& Actor_Waypoint::pose() const {
  const ::gz::msgs::Pose* p = pose_;
  // @@protoc_insertion_point(field_get:gz.msgs.Actor.Waypoint.pose)
  return p != NULL ? *p : *reinterpret_cast<const ::gz::msgs::Pose*>(
      &::gz::msgs::_Pose_default_instance_);
}
inline ::gz::msgs::Pose* Actor_Waypoint::release_pose() {
  // @@protoc_insertion_point(field_release:gz.msgs.Actor.Waypoint.pose)
  
  ::gz::msgs::Pose* temp = pose_;
  pose_ = NULL;
  return temp;
}
inline ::gz::msgs::Pose* Actor_Waypoint::mutable_pose() {
  
  if (pose_ == NULL) {
    auto* p = CreateMaybeMessage<::gz::msgs::Pose>(GetArenaNoVirtual());
    pose_ = p;
  }
  // @@protoc_insertion_point(field_mutable:gz.msgs.Actor.Waypoint.pose)
  return pose_;
}
inline void Actor_Waypoint::set_allocated_pose(::gz::msgs::Pose* pose) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(pose_);
  }
  if (pose) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      pose = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, pose, submessage_arena);
    }
    
  } else {
    
  }
  pose_ = pose;
  // @@protoc_insertion_point(field_set_allocated:gz.msgs.Actor.Waypoint.pose)
}

// -------------------------------------------------------------------

// Actor_Trajectory

// uint32 id = 1;
inline void Actor_Trajectory::clear_id() {
  id_ = 0u;
}
inline ::google::protobuf::uint32 Actor_Trajectory::id() const {
  // @@protoc_insertion_point(field_get:gz.msgs.Actor.Trajectory.id)
  return id_;
}
inline void Actor_Trajectory::set_id(::google::protobuf::uint32 value) {
  
  id_ = value;
  // @@protoc_insertion_point(field_set:gz.msgs.Actor.Trajectory.id)
}

// string type = 2;
inline void Actor_Trajectory::clear_type() {
  type_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Actor_Trajectory::type() const {
  // @@protoc_insertion_point(field_get:gz.msgs.Actor.Trajectory.type)
  return type_.GetNoArena();
}
inline void Actor_Trajectory::set_type(const ::std::string& value) {
  
  type_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:gz.msgs.Actor.Trajectory.type)
}
#if LANG_CXX11
inline void Actor_Trajectory::set_type(::std::string&& value) {
  
  type_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:gz.msgs.Actor.Trajectory.type)
}
#endif
inline void Actor_Trajectory::set_type(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  type_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:gz.msgs.Actor.Trajectory.type)
}
inline void Actor_Trajectory::set_type(const char* value, size_t size) {
  
  type_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:gz.msgs.Actor.Trajectory.type)
}
inline ::std::string* Actor_Trajectory::mutable_type() {
  
  // @@protoc_insertion_point(field_mutable:gz.msgs.Actor.Trajectory.type)
  return type_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Actor_Trajectory::release_type() {
  // @@protoc_insertion_point(field_release:gz.msgs.Actor.Trajectory.type)
  
  return type_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Actor_Trajectory::set_allocated_type(::std::string* type) {
  if (type != NULL) {
    
  } else {
    
  }
  type_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), type);
  // @@protoc_insertion_point(field_set_allocated:gz.msgs.Actor.Trajectory.type)
}

// float tension = 3;
inline void Actor_Trajectory::clear_tension() {
  tension_ = 0;
}
inline float Actor_Trajectory::tension() const {
  // @@protoc_insertion_point(field_get:gz.msgs.Actor.Trajectory.tension)
  return tension_;
}
inline void Actor_Trajectory::set_tension(float value) {
  
  tension_ = value;
  // @@protoc_insertion_point(field_set:gz.msgs.Actor.Trajectory.tension)
}

// repeated .gz.msgs.Actor.Waypoint waypoints = 4;
inline int Actor_Trajectory::waypoints_size() const {
  return waypoints_.size();
}
inline void Actor_Trajectory::clear_waypoints() {
  waypoints_.Clear();
}
inline ::gz::msgs::Actor_Waypoint* Actor_Trajectory::mutable_waypoints(int index) {
  // @@protoc_insertion_point(field_mutable:gz.msgs.Actor.Trajectory.waypoints)
  return waypoints_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::gz::msgs::Actor_Waypoint >*
Actor_Trajectory::mutable_waypoints() {
  // @@protoc_insertion_point(field_mutable_list:gz.msgs.Actor.Trajectory.waypoints)
  return &waypoints_;
}
inline const ::gz::msgs::Actor_Waypoint& Actor_Trajectory::waypoints(int index) const {
  // @@protoc_insertion_point(field_get:gz.msgs.Actor.Trajectory.waypoints)
  return waypoints_.Get(index);
}
inline ::gz::msgs::Actor_Waypoint* Actor_Trajectory::add_waypoints() {
  // @@protoc_insertion_point(field_add:gz.msgs.Actor.Trajectory.waypoints)
  return waypoints_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::gz::msgs::Actor_Waypoint >&
Actor_Trajectory::waypoints() const {
  // @@protoc_insertion_point(field_list:gz.msgs.Actor.Trajectory.waypoints)
  return waypoints_;
}

// -------------------------------------------------------------------

// Actor

// .gz.msgs.Header header = 1;
inline bool Actor::has_header() const {
  return this != internal_default_instance() && header_ != NULL;
}
inline const ::gz::msgs::Header& Actor::_internal_header() const {
  return *header_;
}
inline const ::gz::msgs::Header& Actor::header() const {
  const ::gz::msgs::Header* p = header_;
  // @@protoc_insertion_point(field_get:gz.msgs.Actor.header)
  return p != NULL ? *p : *reinterpret_cast<const ::gz::msgs::Header*>(
      &::gz::msgs::_Header_default_instance_);
}
inline ::gz::msgs::Header* Actor::release_header() {
  // @@protoc_insertion_point(field_release:gz.msgs.Actor.header)
  
  ::gz::msgs::Header* temp = header_;
  header_ = NULL;
  return temp;
}
inline ::gz::msgs::Header* Actor::mutable_header() {
  
  if (header_ == NULL) {
    auto* p = CreateMaybeMessage<::gz::msgs::Header>(GetArenaNoVirtual());
    header_ = p;
  }
  // @@protoc_insertion_point(field_mutable:gz.msgs.Actor.header)
  return header_;
}
inline void Actor::set_allocated_header(::gz::msgs::Header* header) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(header_);
  }
  if (header) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      header = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, header, submessage_arena);
    }
    
  } else {
    
  }
  header_ = header;
  // @@protoc_insertion_point(field_set_allocated:gz.msgs.Actor.header)
}

// .gz.msgs.Entity entity = 2;
inline bool Actor::has_entity() const {
  return this != internal_default_instance() && entity_ != NULL;
}
inline const ::gz::msgs::Entity& Actor::_internal_entity() const {
  return *entity_;
}
inline const ::gz::msgs::Entity& Actor::entity() const {
  const ::gz::msgs::Entity* p = entity_;
  // @@protoc_insertion_point(field_get:gz.msgs.Actor.entity)
  return p != NULL ? *p : *reinterpret_cast<const ::gz::msgs::Entity*>(
      &::gz::msgs::_Entity_default_instance_);
}
inline ::gz::msgs::Entity* Actor::release_entity() {
  // @@protoc_insertion_point(field_release:gz.msgs.Actor.entity)
  
  ::gz::msgs::Entity* temp = entity_;
  entity_ = NULL;
  return temp;
}
inline ::gz::msgs::Entity* Actor::mutable_entity() {
  
  if (entity_ == NULL) {
    auto* p = CreateMaybeMessage<::gz::msgs::Entity>(GetArenaNoVirtual());
    entity_ = p;
  }
  // @@protoc_insertion_point(field_mutable:gz.msgs.Actor.entity)
  return entity_;
}
inline void Actor::set_allocated_entity(::gz::msgs::Entity* entity) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(entity_);
  }
  if (entity) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      entity = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, entity, submessage_arena);
    }
    
  } else {
    
  }
  entity_ = entity;
  // @@protoc_insertion_point(field_set_allocated:gz.msgs.Actor.entity)
}

// .gz.msgs.Pose pose = 3;
inline bool Actor::has_pose() const {
  return this != internal_default_instance() && pose_ != NULL;
}
inline const ::gz::msgs::Pose& Actor::_internal_pose() const {
  return *pose_;
}
inline const ::gz::msgs::Pose& Actor::pose() const {
  const ::gz::msgs::Pose* p = pose_;
  // @@protoc_insertion_point(field_get:gz.msgs.Actor.pose)
  return p != NULL ? *p : *reinterpret_cast<const ::gz::msgs::Pose*>(
      &::gz::msgs::_Pose_default_instance_);
}
inline ::gz::msgs::Pose* Actor::release_pose() {
  // @@protoc_insertion_point(field_release:gz.msgs.Actor.pose)
  
  ::gz::msgs::Pose* temp = pose_;
  pose_ = NULL;
  return temp;
}
inline ::gz::msgs::Pose* Actor::mutable_pose() {
  
  if (pose_ == NULL) {
    auto* p = CreateMaybeMessage<::gz::msgs::Pose>(GetArenaNoVirtual());
    pose_ = p;
  }
  // @@protoc_insertion_point(field_mutable:gz.msgs.Actor.pose)
  return pose_;
}
inline void Actor::set_allocated_pose(::gz::msgs::Pose* pose) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(pose_);
  }
  if (pose) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      pose = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, pose, submessage_arena);
    }
    
  } else {
    
  }
  pose_ = pose;
  // @@protoc_insertion_point(field_set_allocated:gz.msgs.Actor.pose)
}

// string skin_filename = 4;
inline void Actor::clear_skin_filename() {
  skin_filename_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Actor::skin_filename() const {
  // @@protoc_insertion_point(field_get:gz.msgs.Actor.skin_filename)
  return skin_filename_.GetNoArena();
}
inline void Actor::set_skin_filename(const ::std::string& value) {
  
  skin_filename_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:gz.msgs.Actor.skin_filename)
}
#if LANG_CXX11
inline void Actor::set_skin_filename(::std::string&& value) {
  
  skin_filename_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:gz.msgs.Actor.skin_filename)
}
#endif
inline void Actor::set_skin_filename(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  skin_filename_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:gz.msgs.Actor.skin_filename)
}
inline void Actor::set_skin_filename(const char* value, size_t size) {
  
  skin_filename_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:gz.msgs.Actor.skin_filename)
}
inline ::std::string* Actor::mutable_skin_filename() {
  
  // @@protoc_insertion_point(field_mutable:gz.msgs.Actor.skin_filename)
  return skin_filename_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Actor::release_skin_filename() {
  // @@protoc_insertion_point(field_release:gz.msgs.Actor.skin_filename)
  
  return skin_filename_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Actor::set_allocated_skin_filename(::std::string* skin_filename) {
  if (skin_filename != NULL) {
    
  } else {
    
  }
  skin_filename_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), skin_filename);
  // @@protoc_insertion_point(field_set_allocated:gz.msgs.Actor.skin_filename)
}

// float skin_scale = 5;
inline void Actor::clear_skin_scale() {
  skin_scale_ = 0;
}
inline float Actor::skin_scale() const {
  // @@protoc_insertion_point(field_get:gz.msgs.Actor.skin_scale)
  return skin_scale_;
}
inline void Actor::set_skin_scale(float value) {
  
  skin_scale_ = value;
  // @@protoc_insertion_point(field_set:gz.msgs.Actor.skin_scale)
}

// repeated .gz.msgs.Actor.Animation animations = 6;
inline int Actor::animations_size() const {
  return animations_.size();
}
inline void Actor::clear_animations() {
  animations_.Clear();
}
inline ::gz::msgs::Actor_Animation* Actor::mutable_animations(int index) {
  // @@protoc_insertion_point(field_mutable:gz.msgs.Actor.animations)
  return animations_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::gz::msgs::Actor_Animation >*
Actor::mutable_animations() {
  // @@protoc_insertion_point(field_mutable_list:gz.msgs.Actor.animations)
  return &animations_;
}
inline const ::gz::msgs::Actor_Animation& Actor::animations(int index) const {
  // @@protoc_insertion_point(field_get:gz.msgs.Actor.animations)
  return animations_.Get(index);
}
inline ::gz::msgs::Actor_Animation* Actor::add_animations() {
  // @@protoc_insertion_point(field_add:gz.msgs.Actor.animations)
  return animations_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::gz::msgs::Actor_Animation >&
Actor::animations() const {
  // @@protoc_insertion_point(field_list:gz.msgs.Actor.animations)
  return animations_;
}

// bool script_loop = 7;
inline void Actor::clear_script_loop() {
  script_loop_ = false;
}
inline bool Actor::script_loop() const {
  // @@protoc_insertion_point(field_get:gz.msgs.Actor.script_loop)
  return script_loop_;
}
inline void Actor::set_script_loop(bool value) {
  
  script_loop_ = value;
  // @@protoc_insertion_point(field_set:gz.msgs.Actor.script_loop)
}

// float script_delay_start = 8;
inline void Actor::clear_script_delay_start() {
  script_delay_start_ = 0;
}
inline float Actor::script_delay_start() const {
  // @@protoc_insertion_point(field_get:gz.msgs.Actor.script_delay_start)
  return script_delay_start_;
}
inline void Actor::set_script_delay_start(float value) {
  
  script_delay_start_ = value;
  // @@protoc_insertion_point(field_set:gz.msgs.Actor.script_delay_start)
}

// bool script_auto_start = 9;
inline void Actor::clear_script_auto_start() {
  script_auto_start_ = false;
}
inline bool Actor::script_auto_start() const {
  // @@protoc_insertion_point(field_get:gz.msgs.Actor.script_auto_start)
  return script_auto_start_;
}
inline void Actor::set_script_auto_start(bool value) {
  
  script_auto_start_ = value;
  // @@protoc_insertion_point(field_set:gz.msgs.Actor.script_auto_start)
}

// repeated .gz.msgs.Actor.Trajectory trajectories = 10;
inline int Actor::trajectories_size() const {
  return trajectories_.size();
}
inline void Actor::clear_trajectories() {
  trajectories_.Clear();
}
inline ::gz::msgs::Actor_Trajectory* Actor::mutable_trajectories(int index) {
  // @@protoc_insertion_point(field_mutable:gz.msgs.Actor.trajectories)
  return trajectories_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::gz::msgs::Actor_Trajectory >*
Actor::mutable_trajectories() {
  // @@protoc_insertion_point(field_mutable_list:gz.msgs.Actor.trajectories)
  return &trajectories_;
}
inline const ::gz::msgs::Actor_Trajectory& Actor::trajectories(int index) const {
  // @@protoc_insertion_point(field_get:gz.msgs.Actor.trajectories)
  return trajectories_.Get(index);
}
inline ::gz::msgs::Actor_Trajectory* Actor::add_trajectories() {
  // @@protoc_insertion_point(field_add:gz.msgs.Actor.trajectories)
  return trajectories_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::gz::msgs::Actor_Trajectory >&
Actor::trajectories() const {
  // @@protoc_insertion_point(field_list:gz.msgs.Actor.trajectories)
  return trajectories_;
}

// .gz.msgs.Entity parent = 11;
inline bool Actor::has_parent() const {
  return this != internal_default_instance() && parent_ != NULL;
}
inline const ::gz::msgs::Entity& Actor::_internal_parent() const {
  return *parent_;
}
inline const ::gz::msgs::Entity& Actor::parent() const {
  const ::gz::msgs::Entity* p = parent_;
  // @@protoc_insertion_point(field_get:gz.msgs.Actor.parent)
  return p != NULL ? *p : *reinterpret_cast<const ::gz::msgs::Entity*>(
      &::gz::msgs::_Entity_default_instance_);
}
inline ::gz::msgs::Entity* Actor::release_parent() {
  // @@protoc_insertion_point(field_release:gz.msgs.Actor.parent)
  
  ::gz::msgs::Entity* temp = parent_;
  parent_ = NULL;
  return temp;
}
inline ::gz::msgs::Entity* Actor::mutable_parent() {
  
  if (parent_ == NULL) {
    auto* p = CreateMaybeMessage<::gz::msgs::Entity>(GetArenaNoVirtual());
    parent_ = p;
  }
  // @@protoc_insertion_point(field_mutable:gz.msgs.Actor.parent)
  return parent_;
}
inline void Actor::set_allocated_parent(::gz::msgs::Entity* parent) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(parent_);
  }
  if (parent) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      parent = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, parent, submessage_arena);
    }
    
  } else {
    
  }
  parent_ = parent;
  // @@protoc_insertion_point(field_set_allocated:gz.msgs.Actor.parent)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace msgs
}  // namespace gz

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_INCLUDED_gz_2fmsgs_2factor_2eproto
